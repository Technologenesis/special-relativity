{"version":3,"sources":["SpacetimeDiagram.js","App.js","reportWebVitals.js","index.js"],"names":["SpacetimeDiagram","props","state","proper_time","paused","observers","pass_time_in_frame","bind","togglePaused","lastUpdate","Date","now","setInterval","frameSelector","this","showFrameSelector","name","onChange","event","set_perspective","target","value","map","observer","idx","controls","showControls","type","min","maxSpeed","c","max","step","relative_velocity","set_relative_velocity","velocityUnits","spaceUnits","timeUnits","pauseButton","allowPausing","onClick","width","height","yDomain","axisTicksY","xDomain","axisTicksX","title","tickTotal","showTimeOnAxis","position","showTimeDots","data","get_spacetime_intervals","className","showLightRays","x","y","debug","JSON","stringify","parsed_idx","parseInt","velocity","final_velocities","translateVelocity","transform","setState","vel","acceleration","rate","perspective_shift_animation_length","final","interval","transform_to_observer_frame","matrix","transform_from_observer_frame","inv","interval_in_observer_frame","unoriented_interval_in_reference_frame","multiply","time_directionality_aligned","subset","index","interval_in_reference_frame","offset_of_next_interval_tick_in_observer_frame","offset_of_next_interval_tick_in_reference_frame","diagram_bounds","abs","is_in_bounds","point","push","offset","add","delta_t","animateAxisTime","new_vel","new_accel","acceleration_sign","this_idx","parseFloat","React","defaultProps","animation_step","lightColor","gamma","Math","sqrt","v_frame","v_body","dx_body","App","Infinity","displayMode","pi","theta","_","cos","sin","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.6d3dde42.chunk.js","sourcesContent":["import * as React from 'react';\nimport {HorizontalGridLines, LineMarkSeries, LineSeries, VerticalGridLines, XAxis, XYPlot, YAxis} from \"react-vis\";\nimport {matrix, multiply, add, inv, abs, subset, index} from 'mathjs';\n\nclass SpacetimeDiagram extends React.Component {\n    static defaultProps = {\n        paused: true,\n        allowPausing: true,\n        animation_step: .02,\n        perspective_shift_animation_length: .2,\n        showLightRays: true,\n        maxSpeed: .999,\n        debug: false,\n        lightColor: \"yellow\",\n        observers: [],\n        showTimeDots: true,\n        transform: (velocity, c) => {\n            const gamma = 1/Math.sqrt(1-(velocity/c)**2);\n            return [\n                [gamma, -velocity*gamma],\n                [-velocity*gamma/c**2, gamma]\n            ];\n        },\n        c: 1,\n        translateVelocity: (v_frame, v_body, transform) => {\n            const dx_body = v_body;\n            const dt_body = 1;\n            const dxprime_body = transform[0][0]*dx_body + transform[0][1]*dt_body;\n            const dtprime_body = transform[1][0]*dx_body + transform[1][1]*dt_body;\n            return dxprime_body/dtprime_body;\n        },\n        spaceUnits: \"light-seconds\",\n        timeUnits: \"seconds\",\n        axisTicksX: 20,\n        axisTicksY: 10,\n        showTimeOnAxis: true,\n        animateAxisTime: false,\n        showControls: true,\n        showFrameSelector: true\n    }\n\n    constructor(props) {\n        super(props);\n        this.state = {\n            proper_time: 0,\n            paused: props.paused,\n            observers: props.observers\n        };\n        this.pass_time_in_frame = this.pass_time_in_frame.bind(this);\n        this.togglePaused = this.togglePaused.bind(this);\n    }\n\n    componentDidMount() {\n        let lastUpdate = Date.now();\n        setInterval(() => {\n            const now = Date.now();\n            this.pass_time_in_frame((now-lastUpdate)/1000);\n            lastUpdate = now;\n        })\n    }\n\n    render() {\n        const frameSelector = this.props.showFrameSelector ? (\n            <label>Reference Frame: <select name=\"perspective\" onChange={event => this.set_perspective(event.target.value)}>\n                {\n                    this.state.observers.map((observer, idx) => (\n                        <option key={idx} value={idx}>{observer.name}</option>\n                    ))\n                }\n            </select></label>\n        ) : null;\n        const controls = this.props.showControls ? (\n            <div>\n                {\n                    this.state.observers.map((observer, idx) =>\n                        <label key={idx}>V<sub>{observer.name}</sub>: <input type=\"range\" min={-this.props.maxSpeed || -this.props.c} max={this.props.maxSpeed || this.props.c} step=\".01\" value={this.state.observers[idx].relative_velocity} onChange={event => this.set_relative_velocity(idx, event.target.value)}/>{this.state.observers[idx].relative_velocity + \" \" + (this.props.velocityUnits || (this.props.spaceUnits + \"/\" + this.props.timeUnits))}<br/></label>\n                    )\n                }\n            </div>\n        ) : null;\n        const pauseButton = this.props.allowPausing ? (\n            <button onClick={this.togglePaused}>{this.state.paused ? \"Play\" : \"Pause\"}</button>\n        ) : null;\n        return (\n            <div>\n                {frameSelector}<br/>\n                {controls}<br/>\n                {pauseButton}<br/>\n                <XYPlot width={500} height={500} yDomain={[this.state.proper_time, this.state.proper_time+this.props.axisTicksY]} xDomain={[-this.props.axisTicksX/2, this.props.axisTicksX/2]}>\n                    <VerticalGridLines />\n                    <HorizontalGridLines />\n                    <XAxis title={\"Space (\" + this.props.spaceUnits + \")\"}/>\n                    <YAxis title={\"Time (\" + this.props.timeUnits + \")\"} tickTotal={this.props.showTimeOnAxis ? 10 : 0} position=\"middle\"/>\n                    {\n                        this.state.observers.map((observer, idx) => (\n                            this.props.showTimeDots ?\n                                <LineMarkSeries key={idx} data={this.get_spacetime_intervals(observer)} className={observer.name}/>:\n                                <LineSeries key={idx} data={this.get_spacetime_intervals(observer)} className={observer.name}/>\n                        ))\n                    }\n                    {\n                        this.props.showLightRays ? (\n                            <LineSeries data={[\n                                {x: -this.props.axisTicksX/2, y: this.state.proper_time + this.props.axisTicksX/(2*this.props.c)},\n                                {x: 0, y: this.state.proper_time},\n                                {x: this.props.axisTicksX/2, y: this.state.proper_time + this.props.axisTicksX/(2*this.props.c)}]}/>\n                        ) : null\n                    }\n                </XYPlot>\n                <p>{this.props.debug ? JSON.stringify(this.state.observers) : null}</p>\n            </div>\n        );\n    }\n\n    set_perspective(idx) {\n        const parsed_idx = parseInt(idx);\n        const velocity = this.state.observers[parsed_idx].relative_velocity;\n        const final_velocities = this.state.observers.map(observer => {\n            return this.props.translateVelocity(velocity, observer.relative_velocity, this.props.transform(velocity, this.props.c));\n        });\n        this.setState({\n            proper_time: this.state.observers[parsed_idx].proper_time,\n            observers:final_velocities.map((vel, idx) => {\n                const observer = this.state.observers[idx];\n                const acceleration = {\n                    rate: (vel-observer.relative_velocity)/this.props.perspective_shift_animation_length,\n                    final: vel\n                };\n                return {\n                    name: observer.name,\n                    relative_velocity: observer.relative_velocity,\n                    proper_time: observer.proper_time,\n                    acceleration: acceleration\n                }\n            }),\n        });\n    }\n\n    get_spacetime_intervals(observer, interval=1, max=this.props.axisTicksY) {\n        // sticking a lot of consts in here since it's the only way to break up the math a little\n\n        // we grab a matrix for transforming from our current frame into the observer frame\n        const transform_to_observer_frame = matrix(this.props.transform(observer.relative_velocity, this.props.c));\n        // and one for jumping back again\n        const transform_from_observer_frame = inv(transform_to_observer_frame);\n\n        // the interval is given in terms of seconds in the observer reference frame,\n        // which corresponds to a vector in the observer's frame along the time axis\n        const interval_in_observer_frame = matrix([0, interval]);\n        // so we convert this into an interval in our reference frame\n        const unoriented_interval_in_reference_frame = multiply(transform_from_observer_frame, interval_in_observer_frame);\n        // we must also ensure that the time component of our interval is positive\n        const time_directionality_aligned = subset(unoriented_interval_in_reference_frame, index(1)) >= 0;\n        const interval_in_reference_frame = multiply(time_directionality_aligned ? 1 : -1, unoriented_interval_in_reference_frame);\n\n        // we also need a starting point in our current frame.\n        // This is a little complicated, since if the object is going forwards in time, this is its NEXT\n        // tick, while if it's going backwards in time, this will be its LAST tick.\n        const offset_of_next_interval_tick_in_observer_frame = matrix([0, -(observer.proper_time % interval) + (time_directionality_aligned ? interval : 0)]);\n        // now we convert that point into our current reference frame to get a spacetime offset for the first point we'll draw\n        const offset_of_next_interval_tick_in_reference_frame = multiply(transform_from_observer_frame, offset_of_next_interval_tick_in_observer_frame);\n\n        // we only want to draw within the bounds of the graph (plus some extra to ensure we fill the whole thing),\n        // so we denote these bounds here:\n        const diagram_bounds = [\n            [-this.props.axisTicksX / 2 - abs(subset(interval_in_reference_frame, index(0))), -subset(interval_in_reference_frame, index(1))], // minimum\n            [this.props.axisTicksX / 2 + abs(subset(interval_in_reference_frame, index(0))), this.props.axisTicksY + subset(interval_in_reference_frame, index(1))] // maximum\n        ];\n\n        // create a handy way to check if we should keep drawing the line\n        const is_in_bounds = (point) => {\n            return !(subset(point, index(0)) < diagram_bounds[0][0] ||\n                subset(point, index(1)) < diagram_bounds[0][1] ||\n                subset(point, index(0)) > diagram_bounds[1][0] ||\n                subset(point, index(1)) > diagram_bounds[1][1]);\n        };\n\n        // long walk for a short drink of water:\n        let data = [];\n        data.push({x:0, y:this.state.proper_time});\n        for(let offset = offset_of_next_interval_tick_in_reference_frame; is_in_bounds(offset); offset = add(offset, interval_in_reference_frame)) {\n            data.push({x: subset(offset, index(0)), y: subset(offset, index(1))+this.state.proper_time});\n        }\n        return data;\n    }\n\n    pass_time_in_frame(delta_t) {\n        this.setState({\n            proper_time: this.state.paused || !this.props.animateAxisTime ? this.state.proper_time : this.state.proper_time+delta_t,\n            observers: this.state.observers.map((observer) => {\n                let new_vel = observer.relative_velocity;\n                let new_accel = observer.acceleration;\n                if(new_accel != null) {\n                    const acceleration_sign = new_accel.rate < 0;\n                    new_vel = observer.acceleration ? observer.relative_velocity +observer.acceleration.rate*delta_t :\n                        observer.relative_velocity;\n                    const diff_sign = new_accel.final - new_vel < 0;\n                    if(acceleration_sign !== diff_sign) {\n                        new_vel = observer.acceleration.final;\n                        new_accel = null;\n                    }\n                }\n\n                return {\n                    proper_time: this.state.paused ? observer.proper_time : observer.proper_time + delta_t/\n                        this.props.transform(new_vel, this.props.c)[1][1],\n                    relative_velocity: new_vel,\n                    acceleration: new_accel,\n                    name: observer.name\n                }\n            })\n        });\n    }\n\n    set_relative_velocity(idx, velocity) {\n        this.setState({observers: this.state.observers.map((observer, this_idx) => {\n            if(idx === this_idx) {\n                return {\n                    ...observer,\n                    relative_velocity: parseFloat(velocity)\n                }\n            }\n            return observer;\n        })});\n    }\n\n    togglePaused() {\n        this.setState({paused: !this.state.paused});\n    }\n}\n\nexport default SpacetimeDiagram;","import './App.css';\nimport SpacetimeDiagram from \"./SpacetimeDiagram\";\nimport * as React from \"react\";\nimport * as Latex from 'react-latex';\nimport '../node_modules/react-vis/dist/style.css';\nimport {pi, sin, cos} from 'mathjs';\n\nclass App extends React.Component {\n    render() {\n        return (\n            <div>\n                <h1>Special Relativity Visualizer</h1>\n\n                <SpacetimeDiagram observers={[\n                    {\n                        name: \"Observer A\",\n                        proper_time: 0,\n                        relative_velocity: 0\n                    },\n                    {\n                        name: \"Observer B\",\n                        proper_time: 0,\n                        relative_velocity: .5\n                    },\n                    {\n                        name: \"Observer C\",\n                        proper_time: 0,\n                        relative_velocity: -.5\n                    }\n                ]}/>\n\n                <p>Relativity gets a bit of a bad rap for being \"difficult\".  That's not to say it's exactly \"easy\", and\n                certainly not that it's intuitive.  It holds some extremely deep\n                insights into the nature of the world that challenge our everyday experience.  Einstein's name has\n                become synonymous with \"genius\" in part because he was able to come up with the theory from scratch.\n                But it was that part - \"from scratch\" - that earned him his fame.  Luckily for us, the trail is already\n                blazed.  If we want to get an intuition for relativity, we need only retrace the steps.</p>\n\n                <p>The goal of this site is to make the foundations of relativity - in particular, <b>special relativity\n                </b> and the inherent structure of <b>spacetime</b> - accessible through visualization.  After all, the\n                core insights of relativity are supposedly geometric in nature.  So why try to understand it by staring\n                at equations?*</p>\n\n                <p>We'll build up to special relativity gradually, starting with a few \"common sense\" notions.</p>\n\n                <sup>*There will still be equations, but you won't have to read them if you don't want to.</sup>\n\n                <h2>Space and Time</h2>\n\n                <p>We will be using <b>spacetime diagrams</b> to visualize each step in our journey through Special\n                Relativity, so before we go any farther we should figure out how to use them.</p>\n\n                <p>A spacetime diagram is a sort of graph consisting of at least two axes: one for time, and at least one\n                for space.  On it, we chart the paths of various objects through <b>space</b> over <b>time</b>.  Here's\n                an example:</p>\n\n                <SpacetimeDiagram allowPausing={false} showFrameSelector={false} showTimeDots={false} showControls={false} showLightRays={false} spaceUnits=\"meters\" gamma={() => 1} c={Infinity} observers={[\n                    {\n                        name: \"Observer A\",\n                        proper_time: 0,\n                        relative_velocity: 0\n                    },\n                    {\n                        name: \"Observer B\",\n                        proper_time: 0,\n                        relative_velocity: 5\n                    },\n                    {\n                        name: \"Observer C\",\n                        proper_time: 0,\n                        relative_velocity: -1\n                    }\n                ]}/>\n\n                <p>The above diagram shows three objects: one is stationary, one is moving to the right at 5 meters\n                per second, and the third is moving to the left at 1 meter per second.</p>\n\n                <p>This diagram is still very compatible with common-sense.  We have an axis for time which is totally\n                separate from our axis in space.  An object \"moves\" when its position in space changes based on its\n                position in time.  Furthermore, all objects experience time at the same \"rate\" - that is, a second is a\n                second is a second, no matter what velocity you're going.  To visualize this, look at the dots as they\n                move across the lines.  One dot represents the passing of one second for each object:</p>\n\n                <SpacetimeDiagram paused={false} showFrameSelector={false} showControls={false} showLightRays={false} spaceUnits=\"meters\" c={Infinity} observers={[\n                    {\n                        name: \"Observer A\",\n                        proper_time: 0,\n                        relative_velocity: 0\n                    },\n                    {\n                        name: \"Observer B\",\n                        proper_time: 0,\n                        relative_velocity: 5\n                    },\n                    {\n                        name: \"Observer C\",\n                        proper_time: 0,\n                        relative_velocity: -1\n                    }\n                ]}/>\n\n                <p>Note that, although these objects are moving through space over time, their lines on the graph always\n                start at x=0 even as time passes.  In reality, these objects would be moving along the x axis at their\n                given velocity, but we will (usually) ignore this fact for the purpose of keeping all our objects neatly\n                within view, since it is not usually the positions we care about, but the velocities.</p>\n\n                <p>This simple diagram already puts us in a position to think about some of the things we'll be dealing\n                with as we explore relativity.  For instance, plotting space and time together calls into\n                question: just what is the stuff in the middle?  What is it that objects are \"traversing\" as time\n                passes?  And if we consider it as just one object, are distances in space and distances in time\n                unrelated?  These are the questions we will answer when we begin to discuss the geometry underlying the\n                universe itself - <b>spacetime</b>.</p>\n\n                <p>But let's not get too ahead of ourselves.  Now that we know what we'll be looking at, let's dive in\n                and see what the relativity scene looks like pre-Einstein.</p>\n\n                <h2>Galilean Relativity</h2>\n\n                <p>Although the word \"relativity\" is closely associated with Einstein's work, the concept predates him\n                by centuries.  Before Einstein, the word was most closely related to <b>Galileo's principle of\n                relativity</b>, which states that the laws of physics should apply equally regardless of <b>inertial\n                reference frame</b>. In other words, a person cruising along in a spaceship moving at a constant speed\n                follows the same physical laws as a stationary person.  Indeed, it should not be necessary, <i>nor even\n                possible</i>, for either of them to know which of them is moving.\n                </p>\n\n                <p>This sounds like a very simple principle, but it poses a couple of challenges for anyone tasked with\n                transcribing the physical laws of the universe, which must be solved in order.  Firstly, how do we model\n                the change in reference frame?  And secondly, how do we write the laws of physics so that\n                they don't change if we transform our reference frame according to that model?  The first question has a\n                simple, intuitive answer: to translate a velocity from one reference frame to the next, simply subtract\n                the velocity of the new frame.</p>\n\n                <p>\n                    In concrete terms, take a person, Alice, who is riding a train.  Ahead of her, through the window,\n                    she sees Bob by the tracks.  He is standing still on the ground, but relative to Alice, he is moving\n                    towards her at -9 meters per second. Alice throws an apple at 12 meters per second, relative to her,\n                    towards Bob's head.  Assuming that all motion is happening in the same direction, to translate the\n                    apple's velocity into Bob's reference frame, we subtract his velocity from the apple's.\n                    Bob is therefore struck by the apple at 21 meters per second.\n                </p>\n\n                <p>Here's the same scenario in spacetime diagram form.  Try switching between perspectives to understand\n                this relationship and how it appears on the diagram:</p>\n\n                <SpacetimeDiagram showControls={false} showTimeOnAxis={true} showLightRays={false} maxSpeed={50} spaceUnits={\"meters\"} axisTicksX={80} c={Infinity} observers={[\n                    {\n                        name: \"Alice\",\n                        proper_time: 0,\n                        relative_velocity: 0\n                    },\n                    {\n                        name: \"Bob\",\n                        proper_time: 0,\n                        relative_velocity: -9\n                    },\n                    {\n                        name: \"Apple\",\n                        proper_time: 0,\n                        relative_velocity: 12\n                    }\n                ]}/>\n\n                <p>This method of switching between inertial reference frames is called a\n                <b>Galilean transformation</b>, and they form part of the foundation of Newtonian mechanics.  However,\n                by Einstein's time there were some alarming discoveries in physics that seemed to defy this very basic\n                principle: the laws of physics appeared to actually <i>change</i> based on inertial reference frame.\n                It appeared that for all the progress we had made in physics, something was wrong on the very\n                fundamental level.  It turned out that this problem had its roots all the way down at the structure of\n                space and time.\n                </p>\n\n                <h3>Galilean Transformations: A Mathematical Treatment</h3>\n\n                <p>\n                Here I will take a brief mathematical detour to describe these transformations more precisely; feel free\n                to skip to the next section if you're not comfortable with some simple math.  However, if you <i>are</i>\n                comfortable with simple math, I encourage you to read this section.  The symbols may be intimidating,\n                but the math itself is no more complicated than linear functions in pre-algebra.\n                </p>\n\n                <p>\n                    Take a reference frame, <i>S</i>, and some arbitrary coordinates in that frame <i>(x,y,z,t)</i>.\n                    Say we want to translate these coordinates to a new frame, S', which is identical to S except that\n                    it is moving relative to <i>S</i> with velocity <i>v</i> in the positive <i>x</i> direction.  We can\n                    do that transformation as follows:\n                </p>\n\n                <p>\n                x' = x-vt<br/>\n                y' = y<br/>\n                z' = z<br/>\n                t' = t<br/>\n                </p>\n\n                <p>\n                    We can ignore the middle two equations for now since they leave <i>y</i> and <i>z</i> unchanged.\n                    Linear Algebra fans will recognize this as a <b>sheer transformation</b> representable by matrix\n                    multiplication:\n                </p>\n\n                <Latex displayMode={true}>{\n                    '$\\\\begin{bmatrix}' +\n                    'x\\'\\\\\\\\' +\n                    't\\'\\\\\\\\' +\n                    '\\\\end{bmatrix}' +\n                    ' = ' +\n                    '\\\\begin{bmatrix}' +\n                        '1 & -v \\\\\\\\' +\n                        '0 & 1' +\n                    '\\\\end{bmatrix}' +\n                    '\\\\begin{bmatrix}' +\n                        'x\\\\\\\\' +\n                        't\\\\\\\\' +\n                    '\\\\end{bmatrix}$'\n                }</Latex>\n\n                <p>\n                As an example, take a body which starts at position <i>p<sub>0</sub> = (x<sub>0</sub>, y<sub>0</sub>,\n                z<sub>0</sub>)</i> at t=0.  It's moving at a constant velocity of <i>v<sub>body</sub></i> in the x\n                direction in frame S.  Since both our frames and our body are only moving in the x direction, we will\n                deal only with x and t.\n                </p>\n                <p>\n                    We will call the body's <i>x</i> position over time x<sub>body</sub>.  The\n                    constant velocity implies that x<sub>body</sub> varies linearly with t with slope v<sub>body</sub>.\n                    Since x<sub>body</sub> = x<sub>0</sub> at t=0, we see that <i>x<sub>body</sub> = v<sub>body</sub>t+x<sub>0</sub></i>\n                </p>\n                <p>\n                Say we now want to find the velocity <i>v'<sub>body</sub></i> of the body in our secondary reference frame, <i>S'</i>. As in\n                <i>S</i>, we can write our position over time in frame <i>S'</i> as <i>x'<sub>body</sub></i>.\n                    From our first transformation rule, we see that <i>x'<sub>body</sub>=x<sub>body</sub>-vt</i>.\n                By substitution this leads to <i>x'<sub>body</sub>=v<sub>body</sub>t+x<sub>0</sub>-vt</i>.\n                </p>\n\n                <p>\n                    We can rearrange this to arrive at <i>x'<sub>body</sub>=(v<sub>body</sub>-v)t+x<sub>0</sub></i>.\n                    We can use our fourth transformation rule to convert our time coordinate: <i>x'<sub>body</sub>=(v<sub>body</sub>-v)t'+x<sub>0</sub></i>\n                    We see that this is a linear function of t' with constant slope.  The velocity in frame S' is the\n                    change in x' over the change in t', so this constant slope implies a constant velocity\n                    <i>v'<sub>body</sub> = v<sub>body</sub>-v</i>\n                </p>\n\n                <SpacetimeDiagram debug={true} showTimeOnAxis={true} animateAxisTime={false} showLightRays={false} maxSpeed={50} spaceUnits={\"meters\"} axisTicksX={80} c={Infinity} observers={[\n                    {\n                        name: \"Frame S\",\n                        proper_time: 0,\n                        relative_velocity: 0\n                    },\n                    {\n                        name: \"Frame S'\",\n                        proper_time: 0,\n                        relative_velocity: -9\n                    },\n                    {\n                        name: \"body\",\n                        proper_time: 0,\n                        relative_velocity: 12\n                    }\n                ]}/>\n\n                <p>\n                This may seem like a long walk for a short drink of water, but that's only because in this case, the\n                result happens to correspond to our intuition.  We will use similar logic later to uncover some of the\n                bizarre properties of actual spacetime.\n                </p>\n                <p>\n                Note that this math doesn't really correspond to a physical law; we aren't observing how objects\n                <i>behave</i>.  We're describing how they <i>appear</i> to change based on our <i>perspective</i>.  It\n                therefore more closely corresponds to the structure of space itself rather than the laws that govern\n                its contents.\n                </p>\n\n                <h3>Spacetime Intervals: an Early Introduction</h3>\n                <p>\n                When we look at the equations representing Galilean Transformations, we might be tempted to ask why\n                that <i>particular</i> transformation makes so much intuitive sense to us, and what we might find if we\n                adopted a different framework.\n                </p>\n                <p>\n                    There is one critical feature of the Galilean model that makes it a natural choice: it holds the\n                    flow of time constant for all bodies, regardless of their velocity through space.  It's worth noting\n                    that this by no means needs to be the case.\n                </p>\n                <p>\n                    Recall that our spacetime diagram portrays an object's motion through space over time - or,\n                    considered together, <b>spacetime</b>.  In our model, all objects flow through time at the same\n                    rate.  This is actually kind of an interesting property.  Our velocity through all spatial\n                    dimensions can be changed, but we have one, immutable velocity through time.\n                </p>\n\n                <SpacetimeDiagram showFrameSelector={false} showLightRays={false} maxSpeed={10} spaceUnits=\"meters\" c={Infinity} observers={[\n                    {\n                        name: \"Moving Body\",\n                        proper_time: 0,\n                        relative_velocity: 0\n                    }\n                ]}/>\n\n                <p>\n                Notice that no matter how you adjust the object's relative speed, the dots on its line - its flow of\n                time - are equally spread along our graph's time axis.  Further, they always move at the same rate\n                with respect to the time axis.  This makes intuitive sense - it preserves a universal flow of time.  But\n                if we think of our diagram in terms of the stuff in the middle - <b>spacetime</b> - and think of\n                the distance the dots are travelling through it, we notice a strange property.  For very fast bodies,\n                the \"dots\" appear to move very quickly along the line - that is, they appear to <i>speed up</i> through\n                spacetime.\n                </p>\n                <p>\n                And yet, when we switch into that object's frame of reference, its dots are spread out only by the\n                length of one second along the time axis, while it is the dots along our initial axis that are spread\n                out.\n                </p>\n\n                <SpacetimeDiagram paused={false} showControls={false} showLightRays={false} maxSpeed={10} spaceUnits=\"meters\" c={Infinity} observers={[\n                    {\n                        name: \"Initial Reference Frame\",\n                        proper_time: 0,\n                        relative_velocity: 0\n                    },\n                    {\n                        name: \"Fast Body\",\n                        proper_time: 0,\n                        relative_velocity: 10\n                    }\n                ]}/>\n\n                <p>\n                Despite the apparent difference in distance between dots, each body thus appears to experience their\n                movement in the exact same way, and those distances shift dramatically between reference frames.\n                To reflect this, we can develop a notion of <i>distance</i> in our spacetime, defined in such a way that\n                all dots, for all observers, are separated by the same distance.\n\n                We will call this notion of distance the <b>spacetime interval</b>.  The spacetime interval between two\n                points in spacetime will be the amount of time a body travelling between them would experience\n                during its journey.\n\n                Since the dots line up along the time axis no matter what, their distance can be given very simply:\n                where <i>&Delta;s</i> represents the distance between two points in <b>spacetime</b> and <i>&Delta;t</i>\n                represents their distance along the time axis, <i>&Delta;s = &Delta;t</i>.  How bizarre!  Distances in <i>spacetime</i> appear to be totally\n                independent of distance in <i>space</i>!\n                </p>\n                <p>\n                As a little thought experiment, let's think about what would happen if this <i>weren't</i> the case.\n                What if distance through <i>spacetime</i> worked the same way as distance through <i>space</i> - which,\n                as you may recall, is expressed by the <b>Pythagorean theorem</b>:\n                </p>\n\n                <Latex displayMode={true}>{'$\\\\Delta s = \\\\sqrt{\\\\Delta x^2+\\\\Delta y^2+\\\\Delta z^2}$'}</Latex>\n\n                <p>\n                    To describe distance through space<i>time</i>, we could easily slip time into this equation:\n                </p>\n\n                <Latex displayMode={true}>{'$\\\\Delta s = \\\\sqrt{\\\\Delta x^2+\\\\Delta y^2+\\\\Delta z^2+\\\\Delta t^2}$'}</Latex>\n\n                <p>\n                    Let's try plotting this on a spacetime diagram.  It will look a lot like our other ones, only the\n                    dots along each line will no longer be redundant: they will reflect <i>distance</i> through\n                    spacetime along the lines, which the moving body will experience as a second.\n                </p>\n\n                <SpacetimeDiagram maxSpeed={pi} spaceUnits={\"meters\"} axisTicksX={10} velocityUnits={\"radians\"} showLightRays={false} transform={(theta, _) => [\n                    [cos(theta), -sin(theta)],\n                    [sin(theta),  cos(theta)]\n                ]} translateVelocity={(v_frame, v_body, _) => v_body-v_frame} observers={[\n                    {\n                        name: \"Observer A\",\n                        relative_velocity: 0,\n                        proper_time: 0\n                    },\n                    {\n                        name: \"Observer B\",\n                        relative_velocity: pi/4,\n                        proper_time: 0\n                    },\n                    {\n                        name: \"Observer C\",\n                        relative_velocity: -pi/4,\n                        proper_time: 0\n                    }\n                ]}/>\n\n                <h2>A Rip in the Fabric</h2>\n\n                <SpacetimeDiagram paused={false} showLightRays={false} maxSpeed={10} spaceUnits=\"meters\" c={3e8} observers={[\n                    {\n                        name: \"Observer A\",\n                        proper_time: 0,\n                        relative_velocity: 0\n                    },\n                    {\n                        name: \"Observer B\",\n                        proper_time: 0,\n                        relative_velocity: 5\n                    },\n                    {\n                        name: \"Observer C\",\n                        proper_time: 0,\n                        relative_velocity: -1\n                    }\n                ]}/>\n            </div>\n        );\n    }\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}