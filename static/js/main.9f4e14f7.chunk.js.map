{"version":3,"sources":["App.js","reportWebVitals.js","index.js"],"names":["App","props","state","perspective","observers","name","x","relative_velocity","proper_time","set_relative_velocity","bind","lorentzian_transform","setInterval","setState","map","observer","gamma","idx","velocity","this","parsed_idx","parseInt","new_reference_velocity","interval","max","data","current_proper_time","frame_interval","frame_offset","push","y","tick_time_in_current_frame","Math","sqrt","x_prime","t","t_prime","time","onChange","event","set_perpective","target","value","type","min","step","width","height","yDomain","xDomain","title","position","get_spacetime_intervals","className","React","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.9f4e14f7.chunk.js","sourcesContent":["import './App.css';\nimport * as React from \"react\";\nimport {XYPlot, VerticalGridLines, HorizontalGridLines, XAxis, YAxis, LineMarkSeries, LineSeries} from 'react-vis';\nimport '../node_modules/react-vis/dist/style.css';\n\nclass App extends React.Component {\n    constructor(props) {\n        super(props);\n        this.state = {\n            perspective: 0,\n            observers: [\n                {\n                    name: \"Observer A\",\n                    x: 0,\n                    relative_velocity: 0,\n                    proper_time: 0\n                },\n                {\n                    name: \"Observer B\",\n                    x: 0,\n                    relative_velocity: 0.5,\n                    proper_time: 0\n                },\n                {\n                    name: \"Observer C\",\n                    x: 0,\n                    relative_velocity: -0.5,\n                    proper_time: 0\n                }\n        ]};\n        this.set_relative_velocity = this.set_relative_velocity.bind(this);\n        this.lorentzian_transform = this.lorentzian_transform.bind(this);\n    }\n\n    componentDidMount() {\n        setInterval(() => {\n            this.setState({\n                observers: this.state.observers.map(observer => {\n                    return {\n                        name: observer.name,\n                        relative_velocity: observer.relative_velocity,\n                        proper_time: observer.proper_time + .05/this.gamma(observer.relative_velocity)\n                    }\n                })\n            })\n        }, 50);\n    }\n\n    set_relative_velocity(idx, velocity) {\n        let observers = this.state.observers;\n        observers[idx].relative_velocity = velocity;\n        this.setState({observers: observers});\n    }\n\n    set_perpective(idx) {\n        const parsed_idx = parseInt(idx);\n        const new_reference_velocity = this.state.observers[parsed_idx].relative_velocity;\n        this.setState({\n            perspective: parseInt(idx),\n            observers: this.state.observers.map(observer => {\n                return {\n                    name: observer.name,\n                    relative_velocity: (observer.relative_velocity - new_reference_velocity) / (1 - observer.relative_velocity*new_reference_velocity)\n                }\n            })\n        });\n    }\n\n    get_spacetime_intervals(observer, interval=1, max=10) {\n        let data = [];\n        const current_proper_time = this.state.observers[this.state.perspective].proper_time;\n        const frame_interval = this.gamma(observer.relative_velocity); // denotes the time interval in the current reference frame between ticks\n        const frame_offset = current_proper_time+(interval-(observer.proper_time%interval))*this.gamma(observer.relative_velocity);\n        data.push({x: 0, y: current_proper_time});\n        let idx=0;\n        let tick_time_in_current_frame = frame_offset + idx*frame_interval;\n        while(tick_time_in_current_frame <= current_proper_time + max) { // until we hit the top of the graph,\n            data.push({x: observer.relative_velocity*(tick_time_in_current_frame-current_proper_time), y: tick_time_in_current_frame}); // push the next tick onto the worldline\n            idx += 1;\n            tick_time_in_current_frame = frame_offset + idx*frame_interval;\n        }\n        data.push({x: observer.relative_velocity*(tick_time_in_current_frame - current_proper_time), y: tick_time_in_current_frame}); // one more push to make sure the line fills the whole graph\n        return data;\n    }\n\n    lorentzian_transform(velocity) {\n        const gamma = 1/Math.sqrt(1-velocity**2);\n        return {x_prime: (x, t) => gamma*(x-velocity*t), t_prime: (x, t) => gamma*(t-velocity*x)};\n    }\n\n    gamma(velocity) {\n        return 1/Math.sqrt(1-velocity**2);\n    }\n\n    render() {\n        const time = this.state.observers[this.state.perspective].proper_time;\n        return (\n            <div>\n                <form>\n                    <label>Reference Frame: <select name=\"perspective\" onChange={event => this.set_perpective(event.target.value)}>\n                        {\n                            this.state.observers.map((observer, idx) => (\n                                <option key={idx} value={idx}>{observer.name}</option>\n                            ))\n                        }\n                    </select></label><br/>\n                    {this.state.observers.map((observer, idx) => this.state.perspective !== idx ? (\n                        <label key={idx}>V<sub>{observer.name}</sub>: <input type=\"range\" min=\"-.999\" max=\".999\" step=\".01\" value={this.state.observers[idx].relative_velocity} onChange={event => this.set_relative_velocity(idx, event.target.value)}/><br/></label>\n                    ) : null)}\n                </form>\n                <XYPlot width={500} height={500} yDomain={[time, time+10]} xDomain={[-10,10]}>\n                    <VerticalGridLines />\n                    <HorizontalGridLines />\n                    <XAxis title={\"Space (light-seconds)\"}/>\n                    <YAxis title={\"Time (seconds)\"} position=\"middle\"/>\n                    {\n                        this.state.observers.map((observer, idx) => (\n                            <LineMarkSeries key={idx} data={this.get_spacetime_intervals(observer)} className={observer.name}/>\n                        ))\n                    }\n                    <LineSeries data={[{x: 0, y: time}, {x:  10, y: time+10}]}/>\n                    <LineSeries data={[{x: 0, y: time}, {x: -10, y: time+10}]}/>\n                </XYPlot>\n                <h2>How It Works</h2>\n                <p>\n                    What you are looking at is a moving \"Spacetime Diagram\".  It shows the velocity of objects through\n                    spacetime.\n                </p>\n                <p>\n                    Use the \"Reference Frame\" selector to choose what speed will be considered the \"zero\" speed.\n                    The principle of relativity dictates that your choice of reference speed should *not* affect the\n                    nature of physical laws; this diagram demonstrates that.  Notice that regardless of reference frame,\n                    the speed of light remains constant.\n                </p>\n                <p>\n                    You can also adjust the relative speeds of various observers to demonstrate various relativistic\n                    effects.  Each line shows the path an object would take through space-time at the given velocity.\n                    The dots on each line split them into regular intervals.  They may not look regular to you - close\n                    to the speed of light, the dots appear to spread out significantly.  This is due to the odd geometry\n                    of spacetime - in reality, the dots are all separated by the same \"spacetime interval\", which each\n                    observer will experience as a single second along their time axis.  The dots therefore demonstrate\n                    the effects of time dilation.\n                </p>\n            </div>\n        );\n    }\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}